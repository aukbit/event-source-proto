// Code generated by protoc-gen-go. DO NOT EDIT.
// source: eventsource.proto

/*
Package es is a generated protocol buffer package.

It is generated from these files:
	eventsource.proto

It has these top-level messages:
	Query
	Event
	Aggregate
	Ack
*/
package es

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import google_protobuf "github.com/golang/protobuf/ptypes/timestamp"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type Aggregate_Format int32

const (
	Aggregate_PROTOBUF Aggregate_Format = 0
	Aggregate_JSON     Aggregate_Format = 1
	Aggregate_STRING   Aggregate_Format = 2
)

var Aggregate_Format_name = map[int32]string{
	0: "PROTOBUF",
	1: "JSON",
	2: "STRING",
}
var Aggregate_Format_value = map[string]int32{
	"PROTOBUF": 0,
	"JSON":     1,
	"STRING":   2,
}

func (x Aggregate_Format) String() string {
	return proto.EnumName(Aggregate_Format_name, int32(x))
}
func (Aggregate_Format) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{2, 0} }

// Message containing query parameters
type Query struct {
	Params map[string]string `protobuf:"bytes,1,rep,name=params" json:"params,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *Query) Reset()                    { *m = Query{} }
func (m *Query) String() string            { return proto.CompactTextString(m) }
func (*Query) ProtoMessage()               {}
func (*Query) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *Query) GetParams() map[string]string {
	if m != nil {
		return m.Params
	}
	return nil
}

// Message containing the event data
type Event struct {
	// Id is a unique key for the event.
	// NOTE: in most cases should be an auto-increment key, as we want to keep
	// events in order, but order can also be achieved by created_at timestamp
	Id int64 `protobuf:"varint,1,opt,name=id" json:"id,omitempty"`
	// Topic (name) of the event. These should be written in the past tense (user_created)
	Topic string `protobuf:"bytes,2,opt,name=topic" json:"topic,omitempty"`
	// Aggregate to which the event refers to.
	Aggregate *Aggregate `protobuf:"bytes,3,opt,name=aggregate" json:"aggregate,omitempty"`
	// Priority of the event, where 0 is the highest priority.
	Priority int32 `protobuf:"varint,4,opt,name=priority" json:"priority,omitempty"`
	// Signature includes SHA1 signature computed against it's contents and signature of the previous event.
	Signature string `protobuf:"bytes,5,opt,name=signature" json:"signature,omitempty"`
	// Origin of the event. e.g. service name.
	OriginName string `protobuf:"bytes,6,opt,name=origin_name,json=originName" json:"origin_name,omitempty"`
	// Origin of the event. e.g. service ip address / browser.
	OriginIp string `protobuf:"bytes,7,opt,name=origin_ip,json=originIp" json:"origin_ip,omitempty"`
	// Created has the identification of which service has created the event and
	// respective timestamp at which the event ocurred
	Created *google_protobuf.Timestamp `protobuf:"bytes,8,opt,name=created" json:"created,omitempty"`
}

func (m *Event) Reset()                    { *m = Event{} }
func (m *Event) String() string            { return proto.CompactTextString(m) }
func (*Event) ProtoMessage()               {}
func (*Event) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *Event) GetId() int64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *Event) GetTopic() string {
	if m != nil {
		return m.Topic
	}
	return ""
}

func (m *Event) GetAggregate() *Aggregate {
	if m != nil {
		return m.Aggregate
	}
	return nil
}

func (m *Event) GetPriority() int32 {
	if m != nil {
		return m.Priority
	}
	return 0
}

func (m *Event) GetSignature() string {
	if m != nil {
		return m.Signature
	}
	return ""
}

func (m *Event) GetOriginName() string {
	if m != nil {
		return m.OriginName
	}
	return ""
}

func (m *Event) GetOriginIp() string {
	if m != nil {
		return m.OriginIp
	}
	return ""
}

func (m *Event) GetCreated() *google_protobuf.Timestamp {
	if m != nil {
		return m.Created
	}
	return nil
}

// Message containing the aggregate data.
type Aggregate struct {
	Id       string            `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	Schema   string            `protobuf:"bytes,2,opt,name=schema" json:"schema,omitempty"`
	Version  int64             `protobuf:"varint,3,opt,name=version" json:"version,omitempty"`
	Format   Aggregate_Format  `protobuf:"varint,4,opt,name=format,enum=es.Aggregate_Format" json:"format,omitempty"`
	Data     []byte            `protobuf:"bytes,5,opt,name=data,proto3" json:"data,omitempty"`
	Metadata map[string]string `protobuf:"bytes,6,rep,name=metadata" json:"metadata,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *Aggregate) Reset()                    { *m = Aggregate{} }
func (m *Aggregate) String() string            { return proto.CompactTextString(m) }
func (*Aggregate) ProtoMessage()               {}
func (*Aggregate) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *Aggregate) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Aggregate) GetSchema() string {
	if m != nil {
		return m.Schema
	}
	return ""
}

func (m *Aggregate) GetVersion() int64 {
	if m != nil {
		return m.Version
	}
	return 0
}

func (m *Aggregate) GetFormat() Aggregate_Format {
	if m != nil {
		return m.Format
	}
	return Aggregate_PROTOBUF
}

func (m *Aggregate) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

func (m *Aggregate) GetMetadata() map[string]string {
	if m != nil {
		return m.Metadata
	}
	return nil
}

// Message containing successfully event id
type Ack struct {
	Ok bool `protobuf:"varint,1,opt,name=ok" json:"ok,omitempty"`
}

func (m *Ack) Reset()                    { *m = Ack{} }
func (m *Ack) String() string            { return proto.CompactTextString(m) }
func (*Ack) ProtoMessage()               {}
func (*Ack) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *Ack) GetOk() bool {
	if m != nil {
		return m.Ok
	}
	return false
}

func init() {
	proto.RegisterType((*Query)(nil), "es.Query")
	proto.RegisterType((*Event)(nil), "es.Event")
	proto.RegisterType((*Aggregate)(nil), "es.Aggregate")
	proto.RegisterType((*Ack)(nil), "es.Ack")
	proto.RegisterEnum("es.Aggregate_Format", Aggregate_Format_name, Aggregate_Format_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for EventSourceCommand service

type EventSourceCommandClient interface {
	Create(ctx context.Context, in *Event, opts ...grpc.CallOption) (*Ack, error)
}

type eventSourceCommandClient struct {
	cc *grpc.ClientConn
}

func NewEventSourceCommandClient(cc *grpc.ClientConn) EventSourceCommandClient {
	return &eventSourceCommandClient{cc}
}

func (c *eventSourceCommandClient) Create(ctx context.Context, in *Event, opts ...grpc.CallOption) (*Ack, error) {
	out := new(Ack)
	err := grpc.Invoke(ctx, "/es.EventSourceCommand/Create", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for EventSourceCommand service

type EventSourceCommandServer interface {
	Create(context.Context, *Event) (*Ack, error)
}

func RegisterEventSourceCommandServer(s *grpc.Server, srv EventSourceCommandServer) {
	s.RegisterService(&_EventSourceCommand_serviceDesc, srv)
}

func _EventSourceCommand_Create_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Event)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EventSourceCommandServer).Create(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/es.EventSourceCommand/Create",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EventSourceCommandServer).Create(ctx, req.(*Event))
	}
	return interceptor(ctx, in, info, handler)
}

var _EventSourceCommand_serviceDesc = grpc.ServiceDesc{
	ServiceName: "es.EventSourceCommand",
	HandlerType: (*EventSourceCommandServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Create",
			Handler:    _EventSourceCommand_Create_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "eventsource.proto",
}

// Client API for EventSourceProjection service

type EventSourceProjectionClient interface {
	Get(ctx context.Context, in *Event, opts ...grpc.CallOption) (*Event, error)
	List(ctx context.Context, in *Query, opts ...grpc.CallOption) (EventSourceProjection_ListClient, error)
}

type eventSourceProjectionClient struct {
	cc *grpc.ClientConn
}

func NewEventSourceProjectionClient(cc *grpc.ClientConn) EventSourceProjectionClient {
	return &eventSourceProjectionClient{cc}
}

func (c *eventSourceProjectionClient) Get(ctx context.Context, in *Event, opts ...grpc.CallOption) (*Event, error) {
	out := new(Event)
	err := grpc.Invoke(ctx, "/es.EventSourceProjection/Get", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *eventSourceProjectionClient) List(ctx context.Context, in *Query, opts ...grpc.CallOption) (EventSourceProjection_ListClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_EventSourceProjection_serviceDesc.Streams[0], c.cc, "/es.EventSourceProjection/List", opts...)
	if err != nil {
		return nil, err
	}
	x := &eventSourceProjectionListClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type EventSourceProjection_ListClient interface {
	Recv() (*Event, error)
	grpc.ClientStream
}

type eventSourceProjectionListClient struct {
	grpc.ClientStream
}

func (x *eventSourceProjectionListClient) Recv() (*Event, error) {
	m := new(Event)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for EventSourceProjection service

type EventSourceProjectionServer interface {
	Get(context.Context, *Event) (*Event, error)
	List(*Query, EventSourceProjection_ListServer) error
}

func RegisterEventSourceProjectionServer(s *grpc.Server, srv EventSourceProjectionServer) {
	s.RegisterService(&_EventSourceProjection_serviceDesc, srv)
}

func _EventSourceProjection_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Event)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EventSourceProjectionServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/es.EventSourceProjection/Get",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EventSourceProjectionServer).Get(ctx, req.(*Event))
	}
	return interceptor(ctx, in, info, handler)
}

func _EventSourceProjection_List_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(Query)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(EventSourceProjectionServer).List(m, &eventSourceProjectionListServer{stream})
}

type EventSourceProjection_ListServer interface {
	Send(*Event) error
	grpc.ServerStream
}

type eventSourceProjectionListServer struct {
	grpc.ServerStream
}

func (x *eventSourceProjectionListServer) Send(m *Event) error {
	return x.ServerStream.SendMsg(m)
}

var _EventSourceProjection_serviceDesc = grpc.ServiceDesc{
	ServiceName: "es.EventSourceProjection",
	HandlerType: (*EventSourceProjectionServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Get",
			Handler:    _EventSourceProjection_Get_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "List",
			Handler:       _EventSourceProjection_List_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "eventsource.proto",
}

func init() { proto.RegisterFile("eventsource.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 535 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x93, 0xdd, 0x6e, 0xd3, 0x4c,
	0x10, 0x86, 0x63, 0x3b, 0x71, 0xec, 0x49, 0x5b, 0xe5, 0x5b, 0x35, 0x9f, 0x2c, 0x17, 0x68, 0xe4,
	0xa3, 0x48, 0x14, 0x17, 0x85, 0x4a, 0xfc, 0x1d, 0x95, 0xaa, 0xad, 0x8a, 0x20, 0x09, 0x9b, 0x20,
	0x71, 0x86, 0xb6, 0xce, 0xd6, 0x2c, 0xa9, 0xbd, 0x66, 0xbd, 0x89, 0x94, 0x3b, 0xe0, 0x7e, 0xb8,
	0x41, 0xe4, 0xb1, 0x9d, 0x9f, 0x43, 0xce, 0x76, 0xde, 0x77, 0x66, 0x3d, 0xf3, 0x78, 0x16, 0xfe,
	0xe3, 0x2b, 0x9e, 0xea, 0x5c, 0x2e, 0x55, 0xc4, 0xc3, 0x4c, 0x49, 0x2d, 0x89, 0xc9, 0x73, 0xff,
	0x34, 0x96, 0x32, 0x7e, 0xe4, 0xe7, 0xa8, 0xdc, 0x2f, 0x1f, 0xce, 0xb5, 0x48, 0x78, 0xae, 0x59,
	0x92, 0x95, 0x49, 0xc1, 0x2f, 0x68, 0x7d, 0x59, 0x72, 0xb5, 0x26, 0x2f, 0xc0, 0xce, 0x98, 0x62,
	0x49, 0xee, 0x19, 0x7d, 0x6b, 0xd0, 0x19, 0xf6, 0x42, 0x9e, 0x87, 0x68, 0x85, 0x13, 0xd4, 0xaf,
	0x53, 0xad, 0xd6, 0xb4, 0x4a, 0xf2, 0xdf, 0x42, 0x67, 0x47, 0x26, 0x5d, 0xb0, 0x16, 0x7c, 0xed,
	0x19, 0x7d, 0x63, 0xe0, 0xd2, 0xe2, 0x48, 0x8e, 0xa1, 0xb5, 0x62, 0x8f, 0x4b, 0xee, 0x99, 0xa8,
	0x95, 0xc1, 0x3b, 0xf3, 0x8d, 0x11, 0xfc, 0x36, 0xa1, 0x75, 0x5d, 0x74, 0x4b, 0x8e, 0xc0, 0x14,
	0x73, 0x2c, 0xb2, 0xa8, 0x29, 0xe6, 0x45, 0x8d, 0x96, 0x99, 0x88, 0xea, 0x1a, 0x0c, 0xc8, 0x73,
	0x70, 0x59, 0x1c, 0x2b, 0x1e, 0x33, 0xcd, 0x3d, 0xab, 0x6f, 0x0c, 0x3a, 0xc3, 0xc3, 0xa2, 0xb9,
	0xcb, 0x5a, 0xa4, 0x5b, 0x9f, 0xf8, 0xe0, 0x64, 0x4a, 0x48, 0x25, 0xf4, 0xda, 0x6b, 0xf6, 0x8d,
	0x41, 0x8b, 0x6e, 0x62, 0xf2, 0x04, 0xdc, 0x5c, 0xc4, 0x29, 0xd3, 0x4b, 0xc5, 0xbd, 0x16, 0x7e,
	0x62, 0x2b, 0x90, 0x53, 0xe8, 0x48, 0x25, 0x62, 0x91, 0x7e, 0x4f, 0x59, 0xc2, 0x3d, 0x1b, 0x7d,
	0x28, 0xa5, 0x11, 0x4b, 0x38, 0x39, 0x01, 0xb7, 0x4a, 0x10, 0x99, 0xd7, 0x46, 0xdb, 0x29, 0x85,
	0xbb, 0x8c, 0x5c, 0x40, 0x3b, 0x52, 0x9c, 0x69, 0x3e, 0xf7, 0x1c, 0x6c, 0xd1, 0x0f, 0x4b, 0xf4,
	0x61, 0x8d, 0x3e, 0x9c, 0xd5, 0xe8, 0x69, 0x9d, 0x1a, 0xfc, 0x31, 0xc1, 0xdd, 0x8c, 0xb1, 0x83,
	0xc3, 0x45, 0x1c, 0xff, 0x83, 0x9d, 0x47, 0x3f, 0x78, 0xc2, 0x2a, 0x1e, 0x55, 0x44, 0x3c, 0x68,
	0xaf, 0xb8, 0xca, 0x85, 0x4c, 0x11, 0x87, 0x45, 0xeb, 0x90, 0x9c, 0x81, 0xfd, 0x20, 0x55, 0xc2,
	0x34, 0xce, 0x7e, 0x34, 0x3c, 0xde, 0xe3, 0x14, 0xde, 0xa0, 0x47, 0xab, 0x1c, 0x42, 0xa0, 0x39,
	0x67, 0x9a, 0x21, 0x8a, 0x03, 0x8a, 0x67, 0xf2, 0x1a, 0x9c, 0x84, 0x6b, 0x86, 0xba, 0x8d, 0x8b,
	0x70, 0xb2, 0x7f, 0xc7, 0xe7, 0xca, 0x2d, 0xd7, 0x61, 0x93, 0xec, 0xbf, 0x87, 0xc3, 0x3d, 0xeb,
	0x9f, 0x56, 0xe2, 0x0c, 0xec, 0xb2, 0x37, 0x72, 0x00, 0xce, 0x84, 0x8e, 0x67, 0xe3, 0x0f, 0x5f,
	0x6f, 0xba, 0x0d, 0xe2, 0x40, 0xf3, 0xe3, 0x74, 0x3c, 0xea, 0x1a, 0x04, 0xc0, 0x9e, 0xce, 0xe8,
	0xdd, 0xe8, 0xb6, 0x6b, 0x06, 0x3d, 0xb0, 0x2e, 0xa3, 0x45, 0x81, 0x4b, 0x2e, 0xf0, 0x7e, 0x87,
	0x9a, 0x72, 0x31, 0xbc, 0x00, 0x82, 0x6b, 0x35, 0xc5, 0x47, 0x70, 0x25, 0x93, 0x84, 0xa5, 0x73,
	0xf2, 0x0c, 0xec, 0x2b, 0xa4, 0x4d, 0xdc, 0x62, 0x10, 0xcc, 0xf0, 0xdb, 0x38, 0x53, 0xb4, 0x08,
	0x1a, 0xc3, 0x6f, 0xd0, 0xdb, 0xa9, 0x9a, 0x28, 0xf9, 0x93, 0x47, 0xba, 0x60, 0xf9, 0x14, 0xac,
	0x5b, 0xae, 0x77, 0xab, 0xb6, 0xc7, 0xa0, 0x41, 0xfa, 0xd0, 0xfc, 0x24, 0xf2, 0xca, 0xc7, 0x77,
	0xb2, 0xe7, 0xbf, 0x34, 0xee, 0x6d, 0xfc, 0xf3, 0xaf, 0xfe, 0x06, 0x00, 0x00, 0xff, 0xff, 0x7c,
	0xfc, 0x3e, 0xa8, 0x9b, 0x03, 0x00, 0x00,
}
